# Структурное программирование

## Процесс  разработки программного ПО
Разрабатываемую программу принято называть программным проектом , потому что это может быть не одна , а совокупность программ, а так же потому что разрабатывается не просто код программы , а описание создаваемого продукта на всех этапах его создания , в том числе на важнейшем из них этапе проектирования.

### 1.1 Этапы разработки программного проекта

Под разработкой программного проекта понимается весь процесс создания программы под интуитивным понимаем того, для чего предназначена программа и что она должна делать, до получения программного средства удовлетворяющего потребности потенциальных пользователей.

Процесс разработки распадается на отдельные этапы для каждого из которых определены цели и ожидаемые результаты.

Основными этапами разработки являются :

1. Анализ проблем и определение требований - на этом этапе точно определяется постановка цели и спецификация проекта, общие назначения программного проекта и реализуемая им задача, производится выбор или разработка методов решений удовлетворяющий требованиям пользователя, фиксируется программная среда пользовательский интерфейс и общая структура программного средства.
2. Проектирование – на этом этапе определяется детальная структура проекта, четко описываются его компоненты (на естественном языке или языке спецификаций) их взаимодействие между собой (компонентов) и с пользователем, фиксируется представления данных и алгоритмы их обработки.
3. Реализация (кодирование) – на данном этапе выполняется непосредственное кодирование программных проектов на языках программирования.
4. Тестирование – на данном этапе осуществляется проверка в соответствии созданного программного средства заданным спецификациям, причем исполнение функций на специально подготовленном пакете тестов и сравнение ожидаемых результатов с фактическими.
5. Эксплуатация и сопровождение – здесь окончательно устанавливаются соответствия созданного программного средства требованиям пользователей. Производится разумная модификация и создания лучших версий.

### 1.2 Стили разработки проектов.

В связи с тем, что процесс разработки проектов очень сложен , на практике применяется большое количество различных стилей (методов, подходов, парадигм, дисциплин), регламентирующих процесс разработки программ. Следование определенному стилю разработки особенно важно при коллективной работе над программными проектами. При разработке даже небольших систем соблюдение определенного стиля позволяет существенно экономить время их создания и делает программу более качественной. Широкое применение получили такие стили разработки такие как модульный, структурный, надёжный, причем эти стили могут применяться дополняя друг друга.

Другим важным понятием разработки проектов является технология разработки. Каждая технология базируется на некотором стиле и является его конкретным воплощением, она использует определенные программные инструменты и ориентирована на создание программных средств определенного вида.

Технология разработки проектов включают в себя:

1. Язык для описания проектов на разных этапах
2. Инструментальные программные средства в поддержке разработки
3. Методики разработки, то есть совокупность рекомендаций и регламентов обусловленных стилем разработки
Методики разработки проектов в одном и том же программном окружении могут быть различны в зависимости от назначения разрабатываемого программного средства, класса задач, круга пользователей , их уровня знаний и других факторов.

### 1.3 Модульное программирование

Суть модульного программирования состоит в разбиении сложной задачи на некоторое число простых подзадач и составления программ для их решения достаточно независимо друг от друга. Модульность является одним из основных принципов построения программных проектов. В общем случае модуль это отдельное функционально законченная программная единица, которая определенным образом идентифицируется и объединяются с другими подобными модулями. 

Модуль является средством декомпозиции не только структур управления, но и структур данных, этому способствовало понятие тип данных. Модуль является единицей компиляции, хранения , проектирования и раздельной разработки программного проекта коллективом разработчиков, таким образом модуль понимается как средство определения логически связанных логическим объектом , а так же средством их выделения и изоляции. Создание модулей и использование их объектом является одним из приемов экономичного программирования , что обуславливается следующими обстоятельствами:

1. В модуле определяются объекты являющиеся носителями базовых понятий некоторых предметных областей, поэтому модуль задают контекст этой предметной области. Программы которые выполняют различные алгоритмы обработки в этой области могут воспользоваться готовыми одинаковыми определениями базовых объектов.
2. И модули и использующие их программы компилируются независимо (модуль компилируется раньше использующей его программы) благодаря этому, время компиляции большой программы , использующие готовые модули существенно сокращается, это очень важно при отладке больших программ, когда их приходится компилировать многократно.
3. То что он (модуль) скрывает (инкапсулирует представление и реализацию экспортируемых им объектов)так что их возможные изменения в модуле не требует никаких переделок пользовательских программ.

Все модули используют мнемонические имена для определяемых ими объектов (констант, переменных, типов и подпрограмм), что облегчает понимание их назначения и запоминания, а так же удовлетворяет требования наглядности текста программ.

Языки программирования поддерживающие модульный подход описывают модуль как программную единицу состоящую из двух основных частей:

1. Спецификация (интерфейс) – в спецификации приводятся характеристики объектов модуля, которые необходимы и достаточны для использования этих объектов в других модулях и программах. Это позволяет использовать объекты модулей только на основе информации об их интерфейсе не ожидая их полного описания
2. Реализация – в реализационной части модуля описываются представления и алгоритм обработки связанными с теми или иными объектами модуля

Модуль является одним из средств облегчающих верификацию программ. Верификация программы это – доказательство ее правильности путем проверки формальными методами некоторых ее свойств. Модуль как средство созданий абстракции выделяет спецификацию и локализует сведенья о программе. 

Верификация программ складывается из двух этапов:

1. Проверка правильности применения модулей только на основе знания их спецификации.
2. Установления соответствия спецификаций и реализации модулей. Модули так же служат целям создания проблемно-ориентированного контекста и локализации машинной независимости.

### 1.4 Структурное программирование

Стиль структурного программирование регламентирует выполнения этапов проектирования, кодирования и тестирования программ. В структурном программировании важны формы представления программ и дисциплина ее разработки. Оно нацелено на повышение продуктивности в программировании и повышением надежности программ. Одним из главных способов повышения надежности является улучшение структуры программы, что позволяет понимать, сопровождать и модифицировать ее даже без участия автора. 

Модификация программ в процессе их сопровождения и адаптации неизбежно, а стоимость этой модификации обычно в 3-5 раз превышает стоимость создания программы. Структурный стиль особенно актуален при разработке крупных программных проектов с большим коллективом разработчиков. Процесс разработки программы подразумевает ее разбиение на модули, причем, таким образом, что эти модули находятся в отношениях подчинении означающие подчинение не по вызовам одного модуля другим, а подчинение в смысле детализация действий
(разукрупнение) одного модуля подчинённых ему. Этот характер подчинения описывается иерархией модулей , которые подчиненные модули располагаются на более низком, чем подчиняющие их модули. 

Для определения такой иерархии и процесса разработки используют такие понятия как пошаговая детализация , восходящий и нисходящий метод разработки. Пошаговая детализация означает, что весь процесс разработки разбит на шаги выполняемые последовательно. Восходящий метод подразумевает разработки программы снизу вверх, от модулей самого низкого уровня к модулям использующих их. Этот пошаговый процесс завершается, когда будет разработан головной модуль управляющий всем процессом вычислений. Низходящий метод означает обратное движение в процессе разработки - от головного модуля к модулям более низкого уровня. Низходящих является одним из основных принципов структурного программирования. Этот метод разработки означает, что сначала должно быть выполнено низходящее проектирование (построение иерархии модулей), а затем планирование и исполнение процесса кодирования и тестирования программы. Вторым важнейшим принципом структурного программирования является структурное кодирование на языке программирования. Оно имеет два аспекта:

1. Структурирование программ(разбиение) на компоненты
2. Структурность применяемых в программе управляющих конструкций (оператор)

## Нисходящее проектирование

**Нисходящий метод (метод разработки сверху вниз)** - является общим методом человеческой деятельности в борьбе с сложными проблемами  - сведение их решения, упорядочивание последовательности, решение  более простых задач.

При  использовании метода нисходящей разработки можно выполнять параллельно детальное проектирование, кодирование, тестирование и документирование программы. При этом подходе имеется возможность получать надежные и легко проверяемые результаты с самого начала работ.

Нисходящая разработка призвана уменьшить сложность разрабатываемых программ. Она основана  на идее уровня абстракции.

**Абстрагирование** - процесс обобщения, при котором все внимание концентрируется на сходстве явлений и объектов, которые объединяются в группы на основе этого сходства давая тем самым нужную абстракцию. Уровни абстракции  могут быть изображены в виде схемы иерархии, в которой единицей  представления является модуль. Рассматриваемое здесь понятие модуля можно ассоциировать с подпрограммой в языках программирования. Модуль, расположенный на некотором уровне иерархии управляет выполнением  других уровней на следующем уровне иерархии. Такое расслоение программы означает, что любой модуль может активировать (вызвать) подчиненный модуль (модуль более низкого уровня) и возвратить себе управление после завершения его работы.


**Пример**: реализовать простейшие операции по вводу и обработки сводной экзаменационной ведомости группы.


##### Модули первого уровня:

1. А. Выдача формулировки задачи «Укажите операцию с  экзаменационной ведомостью»
	1. Ввести результаты экзаменов студентов группы
	2. Добавить сведения о студентах и предметах
	3. Прочитать сохраненную ведомость
	4. Сохранить ведомость 
	5. Выдать полную информацию о группе по каждому предмету
	6. Посчитать неудовлетворительные оценки
	7. Найти предмет с минимумом/максимумом неудовлетворительных оценок
	8. Завершить работу
2. В. Обработать выбор одной из операций и запустить ее выполнение с использование подпрограмм
3. Повторение А и В бесконечное количество раз

##### Модули второго уровня (используемые модулем первого уровня):

1. Ввод сведений в ведомость
2. Чтение ведомости из файла
3. Запись ведомости в файл
4. Выдача сведений о групппе
5. Подсчет  числа неудовлетворительных оценок
6. Определение предмета с минимальным и максимальным количеством неутов 

##### Модули третьего уровня

2.1 - 3. 1 - Введенная срока является  «Фамилией»
2.1 - 3.2 - Содержит ведомость эту фамилию
2.2, 2.4 - 3.3 - Вывод на экран ведомости
2.5, 2.6 - 3.4 - Число неудовлетворительных оценок по предмету

##### Модули четвертого уровня

3.3 - 4.1 - Вывод заголовка ведомости
3.3 - 4.2 - Вывод сведений о предмете
 
## Планирование, кодирование, тестирование
Неотъемлемым условием нисходящей разработки является планирование. Планированию подлежат как  все  ресурсы используемые при разработке так и порядок детального проектирования модулей их кодирование и тестирование.

Планирование, кодирование, тестирование  - заключается в установлении очередности кодирования и тестирования модулей разных уровней.

Нужно выбирать такой порядок, который наиболее подходит для рассматриваемого проекта. Возможны два варианта направления планирования в  иерархической схеме.

1. Иерархическая модель - сначала кодируются и тестируются все модули одного уровня, затем следующего уровня.
2. Операционная модель -Кодируются и тестируются все модули одной ветви иерархии затем следующие ветви.

В каждой из этих моделей используется понятие «Заглушка».

**Заглушка** - некоторый простой модуль, подменяющий реальный модуль на время тестирования вызывающего модуля и имитирующий в какой-то мере его исполнение.

Например, возвращающий некоторые фиксирующие данные или просто сообщающий о своем исполнении.

При кодировании и тестировании модуля некоторого уровня, используемые им модули более низкого уровня заменяются заглушками.

По окончанию тестирования этого модуля все заглушки заменяются настоящими модулями (которые поочередно кодируются и  тестируются), а виде заглушен представляются их приемники (модули следующего уровня).

В иерархической модели в начале кодирования и тестирования очередного уровня, уже должны быть представлены в виде заглушек все модули этого уровня. Они поочередно заменяются настоящими модулями, одновременно в виде заглушен появляются модули следующего уровня.

В операционной модели модули обычно разрабатываются в порядке их выполнениям готовой программе. Такой подход предпочтительней когда модули одного уровня связаны друг с другом по большому числу сложно структурированных данных.

Нужно сначала создать и проверить модули (как  правило одной ветви) поражающей эти данные, а затем модули использующие эти данные.

Заглушки при этом определяются в порядке определяемым кодируемыми и трестируемыми ветвями вычислений, а не целиком для всего уровня.

Как правило в реальных проектах применяется комбинированный подход сочетающий иерархическую и операционную модель.  Выбегается такое направление кодирования тестирования, которая обеспечивает наиболее полное тестирование модулей  и позволяет как можно раньше решить главные проблемы. Для программы, выполняющей ввод и обработку сводной экзаменационной ведомости и  представлений выше иерархии модулей естественно выбрать комбинацию операционной и иерархической модели. Наиболее важная часть -  модуль первого уровня, содержащий описание структуры ведомости, задание операций над ней и вызов соответствующих модулей второго уровня. Далее,  в первую очередь должны быть реализованы модули второго и третьего уровней, выполняющие ввод ведомости так как без предварительного ее формирования невозможно тестирование никаких других операций. Таким образом  решение основных проблем при разработке этой программы  сосредоточено в головном модуле и одной из ветвей иерархии модулей. Их и  нужно закодировать и протестировать в первую очередь. Реализация  остальных модулей также должна вестись с учетом их преемственности по данным и общности модулей  низших уровней.


## Структурирование программы

**Программа**  - это точное описание обрабатываемых данных и алгоритмов их обработки. Даже в достаточно простых программах качественное описание  обеих этих составляющих давольно сложно и неоднозначно. Одним из главных способов преодоления этой сложности и одновременно обеспечению эффективности - является ее хорошая структурированность.

**Структурирование программ** - это ее разбиение на компоненты с  определенными правилами их расположения в тексте программы и определенными правилами их взаимодействия при исполнении программы. 

**Программный модуль** - это программный компонент, содержащий определение ряда программных объектов. Модули являются носителями описания программных объектов. Которые будучи описаны один раз, могут многократно использоваться в других модулях и программах. Стандартные (библиотечные) модули играют очень важную роль,  предоставляя всем пользовательским программам  множество различных программных объектов. Кроме того, любой программист может сам ввести в употребление модуль, содержащий такие объекты, которые будут необходимы его программе.

**Блок** -  это понятие играющее ключевую роль в понимании процесса исполнения программ и области существования программных объектов. Он состоит из двух частей: описательной (определяющей объекты блока) и исполнительной (задающий их обработку). Блок может содержать в себе другие блоки. Иерархический и  рекурсивный характер описания алгоритмов реализуется в  программе благодаря  использованию механизма подпрограммам, который позволяет описывать параметризованные алгоритмы (тела которых описываются как блоки)  и вызвать их для исполнения с указанными аргументами.

**Подпрограмма** - одно из базовых понятий программирования, не зависящий от языков определяющих его. В виде подпрограмм представляются программные объекты, реализующие некоторую операцию, алгоритм или способ обработки данных. Программа описывается как некая замкнутая программная конструкция, имеющая имя, параметры, и тело. Тело подпрограммы обязательно содержит некоторые операторы обработки данных. Для их выполнения подпрограмма может содержать свои собственные программные объекты локализованные только в ней. Подпрограммы  выполняют важную роль в понимании алгоритма, шагов его исполнения и укрупненных операций обработки данных. Подпрограммы позволяют представлять текст программы более коротко и выразительно. Кроме того фрагмент программы выделенный и описанный в виде подпрограммы  может быть легко тиражируем (путем заимствования его текста) или вызван для исполнения, если эта подпрограмма описана в модуле и экспортируется им.

 **Составные операторы** -  служат целям структурирования программы, позволяя рассматривать некоторую совокупность операторов как единый оператор. Тем самым составные операторы на ряду с другими групповыми операторами (например операторами повторения и выбора) позволяют конструировать иерархическую вложенность операторов. Большое значение для структуры программы  играет ступенчатая запись текста наглядно представляющее иерархию компонентов структурирования.  Она подразумевает, что каждый следующий элемент программы начинается с новой строки в тексте программы  и  имеет относительно начала строки  отступ большего размера чем содержащий его компонент структурирования. Примерами таких инструментов структурирования являются вложенные операторы, вложенные подпрограммы, вложенные описания  (например поля записей) и тому подобное.

Важную роль в  понимании структуры и информативности программы  играют комментарии, содержательно описывающие смысл и назначение компонентов структурирования. 


## Структурность управляющих конструкций

Второй  составляющей структурного программировани является «Структурность применяемых управляющих конструкций языка».

 Это вытекает из требования, чтобы процесс  исполнения управляющих конструкций был легко понимаем по их текстовому представлению. Свойство структурности управляющих конструкций состоит в том, что каждый  из них должен иметь в тексте одну входную точку с которой начинается исполнение конструкций и одну выходную точку в которой завершается исполнение конструкций. Такими конструкциями является условный оператор  (if), оператор варианта (switch), оператор циклов.

Диаграмма оператора варианта:

Точка входа -> вариант 1 -> точка выхода
                        -> вариант 2  ->

Диаграмма оператора цикла с пост условием:

 Точка входа -> тело цикла  -> условие  -> выходим
                                      | <————————| 

Хорошо структурированная программа не должна содержать операторы перехода в произвольную точку текста, композиционно не связанную с текущей точкой.

### Проектирование представления данных

**Выбор представления данных в программе** - весьма важный вопрос разработки. Правильное представление данных свидетельствует о том, что этапа анализа задачи  и проектирования программы действительно были выполнены качественно. На правильное представление данных влияют следующие факторы:

1. Выбор способа задания исходных данных адекватного алгоритма решаемой задачи
2. Описание такой формы представления данных, которая является экономичным для данной задачи
3. Определение таких областей значений исходных данных, которая гарантирует правильность результатов и безотказность исполнения программ

### Выбор типа скалярных данных

При выборе типа для скалярных (простых) данных нужно учитывать разные аспекты. С одной стороны тип данных должен представлять все множество значений, которые  эти данные  могут иметь в задаче, а с другой стороны тип не должен быть избыточным т.е. не следует описывать более широкое множество значений.

Однако тип данных нужно определять не только в зависимости от области значений исходных и  результирующих данных задачи, но и на основе анализа выполняемых в программе вычислений.

Для переменных, принимающих целочисленные значения, для  него выбирают один из целочисленных типов для представления значения этих переменных. Однако диапазон значений этого типа  может оказаться недостаточным для предоставления промежуточных значений т.е. результатов операций над этими переменными.  Если значение  результата выходит за пределы диапазона указанного типа, то результат операции считается не верным.

```
Пример: наиболее ярко такой негативный эффект проявляется в программах вычисляющих с типом integer разные характеристики в графической схеме координат. Не смотря на небольшие значения этих координат (0…360) значения промежуточных результатов (расстояние между двумя точками) могут выходить за границы диапазона типа integer (от - 32768… +32767). В результате этого получаются не верные результаты при расчетах.
```

### Выбор представления набора данных

Одна из основных проблем, возникающих при проектировании программы - выбор подходящего представления набора данных (составных данных). 

Неправильное представление  данных делает программу не надежной, не экономичной, сложной или вообще не адекватной для решаемой задачи. Нужно тщательно проанализировать задачу, требования к ее исходным данным и результатам, алгоритм возможного ее решения, прежде чем описывать данные.

Наборы (последовательности) данных далеко не всегда нужно сохранять или оставлять в памяти исполняемой  программы. Нередко обработку таких данных можно выполнить по мере получения элементов при вводе, чтении из файла или вычисления  элементов.

Правильный выбор представления набора данных возможен только на основе анализа задачи и алгоритма, а не путем формального отображения формулировки задачи. Набор данных в формулировке задачи  может называться как единый составной объект (последовательность, совокупность или множество). В программе же он может представляться не обязательно составным типом данных (массивом, множеством, записью, файлом), а одним  или двумя элементами. 

`Например: вычисление элемента матрицы минимального из максимальных элементов в строках матрицы не требует сохранения максимальных элементов всех строк, т.е. попутно с вычисление максимальных элементов можно осуществлять и нахождение минимального из них.`

### Хранение набора данных

Для долговременно хранения  данных использованных в программе  используются файлы.

**Файл** - представление  последовательности элементов данных произвольной длинны (обычно достаточно большой) в целях ее долговременного хранения (не  только на время исполнения программы). Посредством файлов данные обрабатываемые программой могут быть получены из вне, а результаты  выданы на то или иное устройство или сохранены для последующего  использования.

Важным вопросом проектирования программ  является - **в каких файлах хранить данные и как их при этом структурировать**.

```
Например: текстовый файл рассматривается как последовательность символов, разбитая на строки. Текстовый файл является файлом последовательного доступа - это означает, что любой элемент файла может быть прочитан или записан только если перед ним был прочитан или записан предшевствующий элемент. С последовательным файлом  не  могу одновременно выполняться операции чтения и записи. Целые и вещественные значения в тектовом файле имеют текстовое представление и отделяются друг от друга по крайней мере одним пробелом.
```

**Типизированный файл** - представляет собой последовательность однотипных элементов, с ним можно работать как с файлом последовательного доступа и как с файлом прямого доступа. В котором возможен непосредственный  доступ к любому из его элементов. С таким  файлом можно одновременно исполнять операции чтения и записи (Файлы базы данных).

#### Рекомендации, которые нужно учитывать при проектировании хранения данных в файлах

1. Текстовые файлы могут создаваться с помощью текстового редактора  и содержать данные  разных типов
2. Элементы типизированных файлов хранятся во внутреннем представлении и поэтому должны создаваться программно
3. Типизированные файлы более  надежны так как допускают запись в файл только элементов определенного типа 
4. Даже для последовательной обработки однотипных данных типизированный файл предпочтительней текстового как  в отношении  надежности, так и в отношении скорости выполнения операции 
5. Благодаря непосредственному доступу к своим элементам типизированные файлы представляются очень привлекательными для реализации алгоритмов в которых чередуются операции чтения и записи элементов.

## Объектно ориентированный  подход разработки программных систем

**ООП** -  подразумевает рассмотрение реальных систем как систем взаимодействия обьектов. 

Программные  системы призваны решать задачи, которые возникают в разных областях деятельности человека. Они создаются с помощью средств разработки программ - систем проектирования, языков программирования и операционных систем. Все эти средства имеют под собой математическое основание т.е. логику, теорию конечных автоматов, алгебру и т.д.

Удобнее всего с  их помощью решаются математические, вычислительные задачи. Именно с них и началось программирование. Применение вычислительной техники для решения задач далеких  от математики привело к возникновению проблемы семантического разрыва между выразительными средствами языков программирования и языком на котором сформулированы задачи.

Программные системы предназначены для моделирования реальных систем, поэтому очень важно в каких  терминах  мы пытаемся описывать эти реальные системы. Описание в виде последовательности  действий (процедурный подход)  оказалось слишком сложным. ООП предлагает описывать системы в виде взаимодействия объектов.

Предположим, что мы должны разработать систему  автоматизации банка. Для примера рассмотрим как могла бы осуществляться операция снятия денег через банкомат. 

![](%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/9E826EF3-EA61-46D1-8ED4-A19BD6CDC51F.png)

В данной  операции задействованы три объекта: клиент Иванов, банкомат, счет.

Подойдя к банкомату, засунув карточку, обьектом клиент Иванов посылает банкомату сообщение «Начать работу». Получив такое сообщение, банкомат высвечивает сообщение на экране и запрашивает код доступа т.е. объект банкомат на тверской отправляет сообщение объекту клиент Иванов с секстам «Сообщите идентификационный код» . Если идентификация прошла успешно, обьектом Клиент Иванов просит выдать ему 1000 рублей. Он посылает сообщение банкомату  выдать 1000 рублей, а тот в свою очередь посылает  сообщение проверить «есть ли деньги и снять 100 рублей»  объекту Счет. Приняв это сообщение обьектом Счет проверяет  есть ли у него 1000 рублей, если есть, он пересылает банкомату разрешение на снятие денег, одновременно уменьшая баланс на 1000 рублей. Банкомат выдает деньги и процедура заканчивается. 

Как  видно, в описании терминов объектов достаточно близко к языку предметной области. Составленное описание процедуры взаимодействия  объектов не требует никаких знаний в области программирования и может быть сделано экспертом в предметной области. С другой стороны описание  в терминах  объектов достаточно строгое. Наличие  в объектно ориентированных языках программирования	средств для реализации понятия объекта позволяет сравнительно просто перевести  описание работы банкомата в работающую программу.

Таким образом ООП  выполняет свою первую задачу - это сокращение семантического разрыва между языком предметной области и языком программирования. Описание в виде объектов позволяет вычленить компоненты системы в те же самые объекты «Счет» и «Клиент» будут участвовать и в другой операции при которой клиент приходит в отделение банка для снятия или зачисления денег на счет. 

С другой  стороны в приведенном описании  операции участвуют только существенный  в данном случае объекты. Банкомат состоит из множества частей  и  для того чтобы выдать наличные  он должен осуществить достаточно сложные манипуляции. Однако нас интересует не механическое устройстов банкомата, а его возможности по выдаче денег.  Все внутренние устройство оказывается скрытым, спрятанным внутри объекта «Банкомат».  Подобный принцип построения систем  называемый **«Инкапсуляцией»**  был применен при построении  абстрактных типов данных. Подробности реализации той или иной операции  и внутрення структура объекта не видимы для остальных участников системы.  В приведенном примере даже те операции, которые существенны при построении всей системы могут быть скрыты от конкретных объектов.   Объект «Клиент» взаимодействует с объектом «Банкомат» , но способ реализации метода «Выдать деньги»  не важен для него и он его не знает. Обновляет ли банкомат счет в момент транзакции или же оставляет только запись о транзакции, а обновление  счета произойдет в конце дня - это вопрос реализации. Механизм взаимодействия этих двух объектов определен лишь теми  сообщениями, которые они друг другу посылают. Конкретные действия в том  числе и посылка сообщений другим объекта системы могут изменятся не нарушая работоспособности системы. 

При взаимодействии объектов часто используются модель «клиент-сервер».

**Клиент** - объект, который  запрашивает какие либо действия, выполняемые другим объектом «Сервером». «Клиент» выступает инициатором операции. Объект «Сервер» обеспечивает своими ресурсами выполнение запросов одного или нескольких «Клиентов». Посылка запросов осуществляется  с помощью сообщений. 

**Объект** - что-то чем можно оперировать. У него есть состояние, поведение и возможность отличить его от других объектов.

**Объект** - сущность, способная сохранять свое состояние (информацию) и обеспечивающее набор операций (поведений) для проверки и изменения этого состояния.

**Объект** - модель или абстракция реальной сущности в программной системе.


## Состояние объекта

Каждый объект характеризуется состоянием. Состояние объекта «Банковский счет» - сумма лежащих на нем денег. Состояние  объекта банкомат включает в себя состояние «Включен» или «Выключен»,  «Готов» или  «Не готов» к принятию запроса и наличие денег в банкомате. Состояние объекта характеризуется текущим значением  его атрибутов. В нашем  примере у объекта «Счет» есть атрибут «Баланс». В простейшем  случае  он выражается числом  (количество рублей и копеек).  Операция снятия  со счета и зачисление на счет изменяет баланс и состояние объекта. 

У объекта «Банкомат» имеется несколько атрибутов: количество денег в банкомате может характеризоваться числовым атрибутом,  состояние включен или выключен может выражаться логическим значением, для  которого истина (true) соответствует состоянию «включен», а ложь (false) состоянию «выключен». Так же логическим значением  может выразить готовность банкомата к принятию запросов. 

Атрибутами могут быть не  только простейшие величины (текст, числа, логика), но и сложные величины - объекты.

Предположим  для цели  контроля счета  будет храниться история всех транзакций. Сама по себе транзакция  - это объект, который состоит из нескольких характеристик:

1.  Тип транзакции  «положить» или «снять», 
2. Сумма  денег 
3. Место операции «банкомат или отделение банка»
4. Получатель - источник денег 
5. Дата и время

Таким образом у объекта «Счет» история  транзакций  будет состоять из набора объектов «Транзакция».

Все перечисленные атрибуты объектов могут изменяться, баланс  уменьшается или увеличивается, банкомат включается или выключается, история транзакция пополняется новыми значениями.

Однако не все атрибуты объекта могут изменяться. У объекта «Счет» есть номер, по которому он отличается от всех остальных счетов. В отличие от «баланса», атрибут «номер» не может изменяться. До тех пока счет существует он сохраняет свой номер.  Тоже самое можно сказать об адресе банкомата, идентификационном коде клиента и тд.

## Идентификация объекта 
Метод идентификации объекта должен отвечать на вопрос - «Как отличить один объект от другого?». Другими  словами, если имеются два объекта как определить, что эти объекты разные.

```
Предположим  в мешке лежат шары белого и черного цвета. Будем считать что каждый из них - это объект. Мы вынимаем один шар, рассматриваем его и кладем обратно в мешок. Вытащив два раза шар из мешка, мы хотим  знать - "Вытащили ли мы одинковые шары или один и  тот же шар". Если все шары одного размера и веса и отлечаются только цветом, вытащив подряд два черных шара мы можем определенно утверждать, что шары одинаковые, ответить на вопрос  - "Вытащили ли мы один и тот же шар" не возможно, в данном случае. Ответить на этот вопрос можно только в том случае, если все шары пронумерованы.
```

Точно так же, если программа обращается к двум объектам она может сравнить все известные атрибуты объектов и определить равны ли они. Для того, чтобы сравнить объекты на тождество необходимо, чтобы у каждого объекта существовала некоторая уникальная характеристика. Во многих случаях один из атрибутов объекта по определению является уникальным. Например для всех счетов в банковской системе  атрибут «номер счета» должен быть уникальным, т.е. не может существовать двух счетов с одинаковым номером. Кроме того номер является не изменим атрибутом. Таким образом сравнив номера у двух счетов можно однозначно сделать вывод о тождественности этих объектов. Чтобы такое сравнение работа корректно необходимо принять определенные меры. Создавая новый счет необходимо присваивать ему номер отличный от номеров всех существующих в настоящий момент счетов. Кроме того, необходимо обеспечить неизменяемость номера счета при всех преобразованиях состояния объекта. Таким образом ответственность за правильную идентификацию объекта лежит на программисте, разрабатывающем систему.   Это создает предпосылки для возникновения ошибок. 

Многие объектные модели предлагают встроенные методы идентификации объектов. При создании любого нового объекта ему присваивается уникальный идентификатор  отличающийся от идентификаторов всех остальных объектов, имеющихся в системе. Форма  идентификатора может быть различной: это может быть число с большим диапазоном значений, чтобы хватило на все объекты, адрес в универсальной системе адресации (Например URL для идентификации страниц в интернете) или специальным образом генерируемое имя.

Зная идентификаторы двух объектов  можно сделать вывод об их тождественности или не тождественности. Особое значение правильность идентификации объектов приобретает в распределенных системах, в которых программы, работающие на разных компьютерах,  не зависимо друг от друга в произвольное время создают и уничтожают объекты.

### Интерфейс  объекта 

Важнейшей характеристикой объекта является описание того, как  он может взаимодействовать с окружающим миром - **интерфейс объекта**


Объекты взаимодействуют между собой с  помощью сообщений. Принимая сообщение объект выполняет соответствующее действие. Эти действия называются методами. В нашем примере у объекта «Счет» имеются методы: снять деньги, положить деньги. Эти два метода и составляют интерфейс объекта.  У объекта «Банкомат»  есть как минимум три метода: начать работу, принять деньги, выдать деньги. У объекта «Счет» есть еще атрибут «Баланс», является ли атрибут частью объекта. 

Интерфейс - внешнее описание объекта, при разработке банковской системы, в частности объекта «Счет» мы решаем, является ли «Баланс» информацией необходимой другим  объектам. Очевидно, что является, а что именно нужно знать другим объектам?  Размер баланса. В этом случае необходимо добавить еще один метод к объекты  «Счет» , метод будет называться «Сообщить остаток денег на счете». Получается, что интерфейс объекта счет будет состоять из трех методов. Таким образом атрибут баланс не является непосредственно частью интерфейса. Другие объекты могут обратиться к этому атрибуту только опосредованно с помощью специального метода. 

Другие объекты не могут умножить этот атрибут на два или разделить пополам. Для некоторых объектов разрешены любые операции с некоторыми атрибутами. Например, если объект описывает геометрическую фигуру на экране монитора у него есть атрибуты координаты это фигуры. В зависимости от того, как мы проектируем этот объект мы можем  поместить эти атрибуты в его интерфейс, тогда любые другие объекты могут непосредственно изменять координаты перемещая объект по экрану. Фактически  в таком случае интерфейс объекта состоит из методов: сообщить координаты X, сообщить координату Y, установить координату X, установить координату Y.

На ряду с методами и атрибутами, входящими в интерфейс и доступные другим объектам у объекта могут быть методы и атрибуты, предназначенные для внутреннего употребления, к которым может обращаться только сам объект.

Например у банкомата имеется сложная внутрення структура. И методы, заставляющие эти составные части работать вместе. Но для банковской системы они  не важны. Ни клиент, ни счет не могут к ни обращаться, они не входят в интерфейс объекта банкомат. 

Подводя итог, можно сказать, что объект известен другим объектам только по своему интерфейсу. Внутрення структура его скрыта (инкапсуляция). Важным следствием  является возможность изменения внутренней структуры объекта не зависимо от других взаимодействующих с ним объектов. Если какая-либо часть банкоматов будет заменена в работе всех остальных участников банковской системы никаких изменений не произойдет.

 Применительно к программированию это означает, что намного легче и безопаснее производить модификации системы. Они хорошо локализованным и их эффект предсказуем. Т.е. В случае изменений внутри объекта никакие  другие объекты не должны изменяться.

###  Время жизни  объекта

В любой системе объекты создаются, функционируют и уничтожаются. Рассмотрим традиционную модель выполнения программы.  Чтобы  программа начала выполняться  ее необходимо загрузить в оперативную память компьютера и запустить. По завершению выполнения оперативная память освобождается, а ее состояние пропадает, тоже самое происходит при выключении компьютера. Соответственно все объекты, созданные программой и находящиеся в памяти, уничтожаются. При  следующем запуске той же  самой программы объекты создаются заново, с другими исходными данными и без всякой связи с объектами, существовавшими при предыдущем запуске программы. Время жизни объектов при такой модели выполнения ограничена временем работы программы.  Создание объектов выполняется явно. При этом задавать, когда и какие объекты создаются можно либо на стадии разработки, либо на стадии выполнения.  При написании  программы  в ней объявляются переменные, которые обозначают объекты. Компилятор  обеспечивает создание этих объектов при запуске программы. Динамическое создание объектов на стадии выполнения означает, что программа в ходе своей работы может обращаться к неким особым фабрикам объектов для создания новых объектов.

Фабрика объектов - лишь концептуальное понятие, которое означает  механизм создающий другие объекты. Она может быть реализована в разных вредах по разному. Это может быть особый объект, отдельная функция или отдельная подсистема языка. Удаление объектов зависит от способа их создания. Существует два подхода:

1. Объекты должны уничтожаться явно, с помощью специальных вызовов
2. Объекты уничтожаются тогда, когда они больше никому не нужны

Определить нужны или не нужны объекты можно по тому, используются ли эти объекты  и возможно ли обращение к ним. Если все пути обращения к объектам уничтожены (уничтожены все ссылки на данный объект), то объект становится не доступным  и он уничтожается. Такое уничтожение иногда называется **уничтожения по достижимости**.

Возможно ли существование объектов после завершения программы? Да, возможно, если они создаются не в оперативной памяти, а на постоянном носителе информации. Средой  жизни объектов в таком случае может является например объектно ориентированная база данных. Создание постоянных объектов принципиально отличается от сохранения и восстановления состояния объектов.  Во время работы программы, состояние объекта можно сохранить на постоянном носителе информации, например на диске. При следующем запуске программы она постановит сохраненное  состояние для соответствующего объекта. Одним из часто применяемых методов является  сериализация.  Значения всех атрибутов объекта  записываются в виде строк символов, конкатенируются в месте и результирующая строка записывается в файл на диске.  При восстановлении объекта читается строка из файла, разбивается на подстроки, соответствующие индивидуальным атрибутам объекта и за тем атрибутом присваиваются значения  преобразованные из строк.


![](%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/2E40F61F-8C4F-4C49-829C-63905661CC83.png)


При  сохранении и восстановлении состояния объекта, при новом запуске  программы создается совершенно новый объект. Значения его атрибутов устанавливаются таким образом, что они соответствуют значению атрибутов при предыдущем запуск программы.

Но, если у объекта есть уникальный идентификатор, то он может не совпадать с идентификатором старого объекта.

![](%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/DF42682E-0F17-4862-A702-DF18727A713B.png)

При создании постоянного объекта речь идет именно о сохранении объекта как такового. Иными словами, постоянный объекта не уничтожается при завершении программы и не создается заново при запуске  программы. Программа и при первом и втором запуске обращается к одному и  тому же объекту хранящемуся в постоянной памяти.

Со временем жизни идентификации объектов  тесно связанно понятие объектов первого и второго сорта  или равноправие объектов. Объекты могут стоять из других объектов и ссылаться на другие объекты. Существует ли атрибут объекта как самостоятельный объект или же атрибут объекта - это объект второго сорта существующие лишь как  часть содержащего его объекта.

**Самостоятельный объект** - объект первого сорта, считается  объект если он обладает всеми признаками  идентификации объектов, принятыми в данной объектной среде и время его жизни не связано со  временем жизни поразившего его объекта.

 Если объект  «Эллипс» описывает фигуру, изображенную на экране монитора,  то у него есть атрибут «Цвет» , логично представить что «Цвет» - это тоже объект, у которого есть свои внутренние атрибуты и методы (кодировка RGB,  метод изменить цвет). Существует ли объект цвет эллипса независимо от объекта самого эллипса.  Скорее всего нет, при удалении эллипса  и его цвет исчезнет из системы. Можно ли обратиться к объекту цвет эллипса? Это зависит от реализации, соответственно возможны обе ситуации. У цвета может быть (а может и не быть) уникальный идентификатор объекта, в любом случае цвет эллипса  является объектов второго сорта. Сортность связана с тем, как объект создавался. Яа это же графической системе может существовать параметр «стандартный  цвет эллипса». Этот параметр является объектом , который существует независимо от конкретного эллипса. При изображении фигуры на экране, в зависимости от каких-либо условий  система может использовать стандартный цвет, а может цвет ассоциированной с этой фигурой. Объект «Стандартный цвет эллипса» является объектом первого сорта.

























#Гипич